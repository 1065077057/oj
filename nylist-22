/*
	南阳理工 22 题 取石子（一）
	
	时间限制：3000 ms     内存限制：65535 KB 

	描述 
	一天，TT在寝室闲着无聊，和同寝的人玩起了取石子游戏，而由于条件有限，他/她们是用旺仔小馒头当作石子。游戏的规则是这样的。设有一堆石子，数量为N（1<=N<=1000000），两个人轮番取出其中的若干个，每次最多取M个（1<=M<=1000000），最先把石子取完者胜利。我们知道，TT和他/她的室友都十分的聪明，那么如果是TT先取，他/她会取得游戏的胜利么？

	输入
	第一行是一个正整数n表示有n组测试数据
	输入有不到1000组数据，每组数据一行，有两个数N和M,之间用空格分隔。

	输出
	对于每组数据，输出一行。如果先取的TT可以赢得游戏，则输出“Win”，否则输出“Lose”（引号不用输出）

	样例输入
	2
	1000 1
	1 100

	样例输出
	Lose
	Win
*/

/*
博弈论分析：
这是一种博弈游戏，由此延伸出来了博弈论。讨论的博弈论需要满足以下条件：
1.玩家只有两个人，轮流做出决策
2.游戏的状态集有限，保证游戏在有限步后结束，这样必然会产生不能操作者，其输
3.对任何一种局面，胜负只决定于局面本身，而与轮到哪位选手无关
一般称满足以上条件的游戏称为ICG。

ICG具有两个状态，我们称为必胜态和必败态，他们的关系：
1.后继状态能达到必败的状态为必胜态
2.后继状态都是必胜态，则其为必败态。
一个状态不是必胜态，就是必败态。

这道题是取石子游戏的经典玩法之一，使用了巴什博弈

平衡状态：
平衡状态，又称作奇异局势。当面对这个局势时则会失败。任意非平衡态经过一次操作可以变为平衡态。每个玩家都会努力使自己抓完石子之后的局势为平衡，将这个平衡局势留给对方。因此，玩家A能够在初始为非平衡的游戏中取胜，玩家B能够在初始为平衡的游戏中取胜。

巴什博奕：这道题本质上是利用了巴什博奕。以下为理解巴什博奕后的非定义版：
由于A与B是足够聪明的，巴什博奕就是两个人在足够聪明的情况下互怼。由于足够聪明，所以每次博弈都会将局势转化到对自己有力的情况，而数据总数是固定的，所以在不失误的情况下，先手与后手在游戏开始就已经决定胜负，即可以直接找到奇异局势。
假设总数为n，每次取石子的最大数为m。
反向推导：当最后一次数据为 m+1 的时候，A输（因为最多为m，最小为1）
所以：假设第一A取A个，B取B个，下一次A取的数量为x，进行了k次，有----> n-A-B-k(m+1) = x
可以得到：m+1 与 n 的关系可以推测出最后一次的数据。如果A先手，如果 n%(m+1) != 0 那么说明最后3次博弈的情况下，A可以直接抓取 mA < m 无论让 B 抓取多少石子，总会剩余 <m 的石子----->A胜利

综上：巴什博弈通过 n%(m+1) 来确定奇异局势。
*/

/*代码实现		17ms  147(貌似)*/
import java.util.ArrayList;
import java.util.Scanner;

public class Main{
	public static void main(String[] args){
		Scanner input = new Scanner(System.in);
		ArrayList<Integer> arr = new ArrayList<Integer>();

		int whileTime = input.nextInt();
		int temp = whileTime;
		while(whileTime-- != 0){
			int N = input.nextInt();
			int M = input.nextInt();

			if(N <= M){
				arr.add(1);
			}else{
				if(N%(M+1) != 0){
					arr.add(1);
				}else{
					arr.add(0);
				}
			}
		}
		for(int i = 0;i < temp;i++){
			if(arr.get(i) == 1){
				System.out.println("Win");
			}else{
				System.out.println("Lose");
			}
		}
	}
}
